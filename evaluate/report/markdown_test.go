package report

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/zimmski/osutil/bytesutil"

	"github.com/symflower/eval-dev-quality/evaluate/metrics"
)

// validateFileContent asserts that the file content matches the content of the given file path.
// The expected file is created if it does not exist. If the contents don't match, the actual content is written to disk alongside the expected file.
func validateFileContent(t *testing.T, expectedFilePath string, actualFileContent string) {
	require.NotEmpty(t, expectedFilePath, "expected file path cannot be empty")
	expectedContent, err := os.ReadFile(expectedFilePath)
	if err != nil {
		// Create the file if it does not exist already to make it easy to add new cases.
		require.ErrorIs(t, err, os.ErrNotExist)
		expectedContent = []byte("TODO")
		require.NoError(t, os.WriteFile(expectedFilePath, expectedContent, 0644))
		t.Logf("expected file %q does not exist yet, created it for you", expectedFilePath)
	}

	if !assert.Equalf(t, string(expectedContent), actualFileContent, "actual content:\n%s", actualFileContent) {
		extension := filepath.Ext(expectedFilePath)
		actualFile := strings.TrimSuffix(expectedFilePath, extension) + "_actual" + extension
		require.NoError(t, os.WriteFile(actualFile, []byte(actualFileContent), 0644))
		t.Logf("written actual file content for failing %q to %q", t.Name(), actualFile)
	}
}

func TestMarkdownFormat(t *testing.T) {
	type testCase struct {
		Name string

		// Markdown holds the Markdown values.
		// REMARK Do not set the SVG path in the tests as it is set to a temporary file automatically.
		Markdown Markdown

		ExpectedReport string
		// ExpectedSVGFile is the path to the reference file for the generated SVG content.
		// REMARK If no SVG reference file is set, none will be generated in the template.
		ExpectedSVGFile string
		ExpectedError   error
	}

	validate := func(t *testing.T, tc *testCase) {
		t.Run(tc.Name, func(t *testing.T) {
			temporaryDirectory := t.TempDir()
			if tc.ExpectedSVGFile != "" {
				tc.Markdown.SVGPath = filepath.Join(temporaryDirectory, "test.svg")
			}

			var buffer bytes.Buffer
			actualError := tc.Markdown.Format(&buffer)
			assert.Equal(t, tc.ExpectedError, actualError)
			actualReport := buffer.String()
			actualReport = strings.ReplaceAll(actualReport, temporaryDirectory, "$TEST_DIR")

			assert.Equalf(t, bytesutil.StringTrimIndentations(tc.ExpectedReport), actualReport, "Full output:\n%s", actualReport)

			if tc.ExpectedSVGFile != "" {
				actualSVGContent, err := os.ReadFile(tc.Markdown.SVGPath)
				assert.NoError(t, err)
				validateFileContent(t, tc.ExpectedSVGFile, string(actualSVGContent))
			}
		})
	}

	testTimeString := "2000-01-01 00:00:00"
	testTime, err := time.Parse(time.DateTime, testTimeString)
	require.NoError(t, err)

	validate(t, &testCase{
		Name: "No Models",

		Markdown: Markdown{
			DateTime: testTime,
			Version:  "1234",

			CSVPath: "some/csv/path.csv",
			LogPath: "some/log/path.log",
		},

		ExpectedReport: `
			# Evaluation from 2000-01-01 00:00:00

			This report was generated by [DevQualityEval benchmark](https://github.com/symflower/eval-dev-quality) in ` + "`" + `version 1234` + "`" + `.

			## Results

			> Keep in mind that LLMs are nondeterministic. The following results just reflect a current snapshot.

			The results of all models have been divided into the following categories:
			- Category Unknown: Models in this category could not be categorized.
			- Response Error: Models in this category encountered an error.
			- Response Empty: Models in this category produced an empty response.
			- No Code: Models in this category produced no code.
			- Invalid Code: Models in this category produced invalid code.
			- Executable Code: Models in this category produced executable code.
			- Statement Coverage Reached: Models in this category produced code that reached full statement coverage.
			- No Excess Response: Models in this category did not respond with more content than requested.

			The following sections list all models with their categories. The complete log of the evaluation with all outputs can be found [here](some/log/path.log). Detailed scoring can be found [here](some/csv/path.csv).

		`,
	})

	validate(t, &testCase{
		Name: "Simple Models",

		Markdown: Markdown{
			DateTime: testTime,
			Version:  "1234",

			CSVPath: "some/csv/path.csv",
			LogPath: "some/log/path.log",

			TotalScore: 1,
			AssessmentPerModel: map[string]metrics.Assessments{
				"ModelResponseError": metrics.NewAssessments(),
				"ModelNoCode": metrics.Assessments{
					metrics.AssessmentKeyResponseNoError:  1,
					metrics.AssessmentKeyResponseNotEmpty: 1,
				},
			},
		},

		ExpectedReport: `
			# Evaluation from 2000-01-01 00:00:00

			![Bar chart that categorizes all evaluated models.]($TEST_DIR/test.svg)

			This report was generated by [DevQualityEval benchmark](https://github.com/symflower/eval-dev-quality) in ` + "`" + `version 1234` + "`" + `.

			## Results

			> Keep in mind that LLMs are nondeterministic. The following results just reflect a current snapshot.

			The results of all models have been divided into the following categories:
			- Category Unknown: Models in this category could not be categorized.
			- Response Error: Models in this category encountered an error.
			- Response Empty: Models in this category produced an empty response.
			- No Code: Models in this category produced no code.
			- Invalid Code: Models in this category produced invalid code.
			- Executable Code: Models in this category produced executable code.
			- Statement Coverage Reached: Models in this category produced code that reached full statement coverage.
			- No Excess Response: Models in this category did not respond with more content than requested.

			The following sections list all models with their categories. The complete log of the evaluation with all outputs can be found [here](some/log/path.log). Detailed scoring can be found [here](some/csv/path.csv).

			### "Response Error"

			Models in this category encountered an error.

			- ` + "`ModelResponseError`" + `

			### "No Code"

			Models in this category produced no code.

			- ` + "`ModelNoCode`" + `

		`,
		ExpectedSVGFile: "testdata/two_models.svg",
	})
}

func TestBarChartModelsPerCategoriesSVG(t *testing.T) {
	type testCase struct {
		Name string

		Categories        []*metrics.AssessmentCategory
		ModelsPerCategory map[*metrics.AssessmentCategory]uint

		ExpectedFile  string
		ExpectedError error
	}

	validate := func(t *testing.T, tc *testCase) {
		t.Run(tc.Name, func(t *testing.T) {
			var actualSVGContent bytes.Buffer
			dummyModelsPerCategory := make(map[*metrics.AssessmentCategory][]string)
			for category, count := range tc.ModelsPerCategory {
				dummyModelsPerCategory[category] = make([]string, count)
			}

			actualError := barChartModelsPerCategoriesSVG(&actualSVGContent, tc.Categories, dummyModelsPerCategory)
			assert.Equal(t, tc.ExpectedError, actualError)

			validateFileContent(t, tc.ExpectedFile, actualSVGContent.String())
		})
	}

	validate(t, &testCase{
		Name: "Two Categories",

		Categories: []*metrics.AssessmentCategory{
			metrics.AssessmentCategoryResponseError,
			metrics.AssessmentCategoryResponseNoCode,
		},
		ModelsPerCategory: map[*metrics.AssessmentCategory]uint{
			metrics.AssessmentCategoryResponseError:  1,
			metrics.AssessmentCategoryResponseNoCode: 3,
		},

		ExpectedFile: "testdata/two_categories.svg",
	})

	validate(t, &testCase{
		Name: "All Categories",

		Categories: metrics.AllAssessmentCategories,
		ModelsPerCategory: map[*metrics.AssessmentCategory]uint{
			metrics.AssessmentCategoryResponseError:                1,
			metrics.AssessmentCategoryResponseEmpty:                2,
			metrics.AssessmentCategoryResponseNoCode:               3,
			metrics.AssessmentCategoryCodeInvalid:                  4,
			metrics.AssessmentCategoryCodeExecuted:                 5,
			metrics.AssessmentCategoryCodeCoverageStatementReached: 6,
			metrics.AssessmentCategoryCodeNoExcess:                 7,
		},

		ExpectedFile: "testdata/all_categories.svg",
	})
}
